{
    "name": "tensorflow",
    "cve_id": "CVE-2021-29534",
    "publish_date": "2021-05-14T20:15Z",
    "cwe_id": "CWE-754",
    "owner": "Google Inc.",
    "affected_versions": [
        {
            "version_value": "2.5.0",
            "operator": "<"
        }
    ],
    "references": [
        "https://github.com/tensorflow/tensorflow/commit/69c68ecbb24dff3fa0e46da0d16c821a2dd22d7c",
        "https://github.com/advisories/GHSA-6j9c-grc6-5m6g",
        "https://nvd.nist.gov/vuln/detail/CVE-2021-29534",
        "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-6j9c-grc6-5m6g"
    ],
    "description": "From NVD:\nTensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.SparseConcat`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/b432a38fe0e1b4b904a6c222cbce794c39703e87/tensorflow/core/kernels/sparse_concat_op.cc#L76) takes the values specified in `shapes[0]` as dimensions for the output shape. The `TensorShape` constructor(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L183-L188) uses a `CHECK` operation which triggers when `InitDims`(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L212-L296) returns a non-OK status. This is a legacy implementation of the constructor and operations should use `BuildTensorShapeBase` or `AddDimWithStatus` to prevent `CHECK`-failures in the presence of overflows. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\nFrom Github:\n### Impact\nAn attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.SparseConcat`: \n\n```python\nimport tensorflow as tf\nimport numpy as np\n\nindices_1 = tf.constant([[514, 514], [514, 514]], dtype=tf.int64)\nindices_2 = tf.constant([[514, 530], [599, 877]], dtype=tf.int64)\nindices = [indices_1, indices_2]\n\nvalues_1 = tf.zeros([0], dtype=tf.int64)\nvalues_2 = tf.zeros([0], dtype=tf.int64)\nvalues = [values_1, values_2]\n\nshape_1 = tf.constant([442, 514, 514, 515, 606, 347, 943, 61, 2], dtype=tf.int64)\nshape_2 = tf.zeros([9], dtype=tf.int64)\nshapes = [shape_1, shape_2]\n\ntf.raw_ops.SparseConcat(indices=indices, values=values, shapes=shapes, concat_dim=2)\n```\n\nThis is because the [implementation](https://github.com/tensorflow/tensorflow/blob/b432a38fe0e1b4b904a6c222cbce794c39703e87/tensorflow/core/kernels/sparse_concat_op.cc#L76) takes the values specified in `shapes[0]` as dimensions for the output shape:\n\n```cc\nTensorShape input_shape(shapes[0].vec<int64>());\n```\n\nThe [`TensorShape` constructor](https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L183-L188) uses a `CHECK` operation which triggers when [`InitDims`](https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L212-L296) returns a non-OK status.\n\n```cc\ntemplate <class Shape>\nTensorShapeBase<Shape>::TensorShapeBase(gtl::ArraySlice<int64> dim_sizes) {\n  set_tag(REP16);\n  set_data_type(DT_INVALID);\n  TF_CHECK_OK(InitDims(dim_sizes));\n}\n```\n\nIn our scenario, this occurs when adding a dimension from the argument results in overflow:\n\n```cc\ntemplate <class Shape>\nStatus TensorShapeBase<Shape>::InitDims(gtl::ArraySlice<int64> dim_sizes) {\n  ...\n  Status status = Status::OK();\n  for (int64 s : dim_sizes) {\n    status.Update(AddDimWithStatus(internal::SubtleMustCopy(s)));\n    if (!status.ok()) {\n      return status;\n    }\n  }\n}\n\ntemplate <class Shape>\nStatus TensorShapeBase<Shape>::AddDimWithStatus(int64 size) {\n  ...\n  int64 new_num_elements;\n  if (kIsPartial && (num_elements() < 0 || size < 0)) {\n    new_num_elements = -1;\n  } else {\n    new_num_elements = MultiplyWithoutOverflow(num_elements(), size);\n    if (TF_PREDICT_FALSE(new_num_elements < 0)) {\n        return errors::Internal(\"Encountered overflow when multiplying \",\n                                num_elements(), \" with \", size,\n                                \", result: \", new_num_elements);\n      }\n  }\n  ...\n}\n```\n\nThis is a legacy implementation of the constructor and operations should use `BuildTensorShapeBase` or `AddDimWithStatus` to prevent `CHECK`-failures in the presence of overflows.\n\n### Patches\nWe have patched the issue in GitHub commit [69c68ecbb24dff3fa0e46da0d16c821a2dd22d7c](https://github.com/tensorflow/tensorflow/commit/69c68ecbb24dff3fa0e46da0d16c821a2dd22d7c).\n\nThe fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n### For more information\nPlease consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.\n\n### Attribution\nThis vulnerability has been reported by Yakun Zhang and Ying Wang of Baidu X-Team.",
    "latest_version": "2.3.1",
    "language": "python",
    "license": "Apache-2.0",
    "repository_summary": "TensorFlow is an open source machine learning framework for everyone.",
    "repo_url": "https://www.tensorflow.org/",
    "impact": {
        "cvss2_score": 2.1,
        "cvss2_severity": "LOW",
        "vector_string": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
        "av": "LOCAL",
        "ac": "LOW",
        "pr": "LOW",
        "c": "NONE",
        "i": "NONE",
        "a": "HIGH",
        "impact_score": 3.6,
        "exploitability_score": 1.8,
        "cvss3_score": 5.5,
        "cvss3_severity": "MEDIUM",
        "ui": "NONE",
        "s": "UNCHANGED"
    },
    "ochrona_severity_score": 5.5
}